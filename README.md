# Лабораторная работа 14: CompletableFuture и асинхронное программирование

# Лабораторная работа 14: CompletableFuture и асинхронное программирование

## 1. Общая информация

**Дисциплина:** Программирование на Java  
**Тема:** Асинхронное программирование. CompletableFuture.  
**Лабораторная работа №14**  
**Студент:** Искандер Байбатыров  
**Группа:** _укажи свою_  
**Преподаватель:** Мусина Айгерим  
**Дата выполнения:** _дата_  

---

# 2. Цель работы

Изучить принципы асинхронного и параллельного программирования в Java, освоить использование `CompletableFuture`, научиться строить асинхронные цепочки операций, комбинировать их, обрабатывать ошибки, настраивать исполнители (ExecutorService) и анализировать производительность.

---

# 3. Постановка задачи

Разработать систему обработки заказов интернет-магазина, используя:

- `CompletableFuture`
- цепочки зависимых async-операций (`thenCompose`)
- параллельные операции (`thenCombine`, `allOf`)
- обработку ошибок (`handle`, `exceptionally`)
- контроль времени (`orTimeout`)
- кастомный ExecutorService
- детальный анализ производительности

Обработка заказа выполняется по этапам:

1. Проверка наличия товара  
2. Расчёт итоговой стоимости  
3. Обработка платежа  
4. Резервирование товара  
5. Уведомление клиента  

Несколько заказов должны обрабатываться параллельно.

---

# 4. Структура проекта

Lab14_CompletableFuture/
│
├── src/
│ ├── Order.java
│ ├── Product.java
│ ├── OrderResult.java
│ ├── OrderProcessingService.java
│ └── OrderProcessor.java
│
└── README.md

# результаты:
![1](screen/2223.png)
![2](screen/2224.png)
# 5. Описание реализованных классов

### **Order.java**
Хранит данные заказа: id заказа, id товара, количество, email клиента.

### **Product.java**
Хранит данные товара: id, название, цена, остаток.

### **OrderResult.java**
Содержит информацию о результате обработки заказа:
- успешность  
- итоговая сумма  
- сообщение  
- id заказа  

### **OrderProcessingService.java**

Реализует все этапы асинхронной обработки:

| Метод | Назначение | Задержка |
|-------|------------|----------|
| `checkProductAvailability()` | Проверка наличия товара | ~1 сек |
| `calculatePrice()` | Цена + скидка + налог | ~0.5 сек |
| `processPayment()` | Оплата (10% шанс неудачи) | ~2 сек |
| `reserveProduct()` | Резервирование | ~0.8 сек |
| `sendNotification()` | E-mail уведомление | ~1 сек |
| `processOrder()` | Полный async-конвейер | завис. |

Ошибки обрабатываются через:

- `exceptionally`
- `handle`
- `whenComplete`

Время ограничено:

- `orTimeout(10, TimeUnit.SECONDS)`

### **OrderProcessor.java**
- создаёт тестовые заказы  
- запускает обработку  
- использует `CompletableFuture.allOf()`  
- выводит статистику  

---

# 6. Используемые методы CompletableFuture

| Метод | Применение |
|--------|------------|
| `supplyAsync` | запуск async-операции |
| `runAsync` | запуск задачи без возвращаемого значения |
| `thenApply` | преобразование результата |
| `thenCompose` | последовательные async-задачи |
| `thenCombine` | объединение независимых async-результатов |
| `allOf` | ожидание списка задач |
| `orTimeout` | ограничение времени |
| `exceptionally` | обработка ошибки |
| `handle` | получение результата + ошибки |
| `whenComplete` | логирование |
| `join` | получение результата без checked исключений |

---
# 7.Анализ асинхронности и производительности (обновлённый, расширенный)
1. Последовательная модель

Если бы заказ обрабатывался синхронно:

Этап	Время
Проверка товара	1000 ms
Расчёт цены	500 ms
Платёж	2000 ms
Резервирование	800 ms
Уведомление	1000 ms
Итого	≈ 5.3 сек / заказ

10 заказов → 53 секунды.

2. Асинхронная модель (CompletableFuture)

Каждый заказ выполняется в отдельном потоке:

задержки не блокируют CPU

цепочки выполняются параллельно

итоговое время определяется самым долгим заказом

10 заказов обрабатываются за 5–8 секунд,
а не за 50+ секунд.

3. Почему асинхронность ускоряет работу

Java-потоки простаивают во время sleep, но CPU свободен

другие заказы продолжают выполнение

нет лишних блокировок

можно держать десятки параллельных async операций

На практике системы интернет-магазинов ВСЕГДА работают асинхронно из-за высокой доли I/O.

4. Различие между I/O-bound и CPU-bound задачами
I/O-bound (наш случай)

задержки не нагружают процессор

можно запускать сотни async задач

async — идеальный выбор

CPU-bound

тяжёлые вычисления

async даёт мало пользы

количество потоков не должно превышать число ядер

5. Ограничения асинхронности

Перегрузка commonPool.

Большое число маленьких задач → overhead.

Ошибки без handle() ломают всю цепочку.

Слишком глубокие цепи вызывают трудную отладку.

6. Итог анализа

Асинхронность CompletableFuture:

увеличивает пропускную способность

снижает суммарное время обработки

позволяет масштабировать систему

делает сервис отзывчивым

идеально подходит для веб-сервисов, платежей, API, БД

Использование CompletableFuture полностью оправдано и эффективно для моделируемой предметной области.

# 8.Выводы

CompletableFuture является мощным инструментом для построения асинхронных конвейеров.

Использование цепочек операций позволяет создавать гибкую, масштабируемую архитектуру.

Параллелизм обеспечивает значительное ускорение обработки заказов.

Механизмы обработки ошибок делают систему устойчивой.

Асинхронность подходит, когда процессы включают задержки и внешние запросы.

Производительность системы возрастает многократно при большом числе заказов.
